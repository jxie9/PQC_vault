{
	"nodes":[
		{"id":"2b4333f04533c137","type":"text","text":"Fast and Efficient Hardware Implementation of HQC\nhttps://eprint.iacr.org/2022/1183","x":-200,"y":-300,"width":585,"height":100},
		{"id":"20994a817c426765","x":-200,"y":-140,"width":585,"height":820,"type":"text","text":"Algorithm 2 (HQC.PKE.KeyGen() and HQC.KEM.KeyGen())\n- Hamming weights $w$ are hardcoded depending on security level\n1) $h \\leftarrow \\textit{R}$\n\t- A polynomial $h$ is chosen uniformly randomly from the quotient ring $\\textit{R}$ on which vectors and operations of HQC are defined\n\t- So, a random binary vector of length $n$\n2) $(x,y) \\leftarrow^w \\textit{R}^2$\n\t- Polynomials $(x,y)$ are chosen uniformly random from $R^2$ (I believe a cartesian product) with a Hamming weight of $w$ (Choose $w$ positions to be 1, rest 0)\n\t- Something about sparsity here and how it's analogous to LWE's short vectors (?)\n\t- $(x,y)$ are the secret vectors of HQC\n3) $s := x+h\\cdot y$ \n\t- Let s be $x+h\\cdot y$\n\t- Since h and y are binary vectors, product is cyclical convolution with coefficients mod 2\n\t\t- $h$ is the random matrix\n\t\t- $y$ is the secret key\n\t\t- $x$ is the error term\n4) **return** $(pk := (h,s), sk := (x,y))$\n\t- Public key is the pair, random polynomial $h$ and the computed polynomial $s$\n\t- Secret key is the pair of sparse polynomials $(x,y)$"},
		{"id":"c988c97f555a4499","x":460,"y":-140,"width":585,"height":820,"type":"text","text":"Algorithm 3 HQC.PKE.Encrypt(pk = (h, s), m, $\\theta$)\n- Provided the public key (containing random polynomial $h$ and polynomial compute $s$), the message $m$, and a noise generated seed, $\\theta$\n- Hamming weights $w_r$ are hardcoded depending on security level\n\t- Not really sure where $\\theta$ comes from yet - PRG maybe?\n1) $(r_1, r_2, e) \\leftarrow^{w_r, \\theta} \\textit{R}^3$ \n\t- Masking noise polynomials $r_1, r_2$ are sampled uniformly random from $\\textit{R}^3$ with Hamming weight $w_r$\n\t- Message noise polynomial $e$ is sampled uniformly random from $R^3$ with Hamming weight $\\theta$\n2) $u := r_1 + h \\cdot r_2$\n\t- Let $u$ be $r_1 + h \\cdot r_2$\n\t- Same as $s$ compute in KeyGen algorithm\n\t- Encodes $h$ with noisy polynomials $r_1, r_2$\n3) $t := Encode(m)$\n\t- Let $t$ be the encoded message $m$\n\t- Encoding is done by matrix vector multiplication between a hardcoded Generator matrix and a message - encode function of concatenated Reed-Muller and Reed-Solon codes\n\t- The paper noted that given $c = mG$, the codeword is given by duplicating $c$ 3 or 5 times depending on security level\n4) $v := t + s \\cdot r_2 + e$\n\t- Let $v$ be the compute of the masked message (hides encoded message using public key with some noise $e$)\n5) **return** $c := (u,v)$\n\t- Returns the ciphertext comprised of compute polynomials $u,v$"},
		{"id":"60c2fef383b74e2b","x":1120,"y":-140,"width":585,"height":820,"type":"text","text":"Algorithm 4 HQC.PKE.Decrypt(sk = (x, y), c = (u, v))\n- Provided the two generated key's secret key $x,y$ and the ciphertext $u,v$ \n1) $m' := Decode(v - u \\cdot y)$\n\t- Let $m'$ be the decoded message $m$\n\t- Decoding is done by matrix vector multiplication between a hardcoded Generator matrix and a message - encode function of concatenated Reed-Muller and Reed-Solon codes\n\t- The paper noted that given $c = mG$, the codeword is given by duplicating $c$ 3 or 5 times depending on security level\n2) **return** $m'$"}
	],
	"edges":[
		{"id":"3e4b52fa64663cc9","fromNode":"2b4333f04533c137","fromSide":"bottom","toNode":"20994a817c426765","toSide":"top"},
		{"id":"d6e6e291c837b89a","fromNode":"2b4333f04533c137","fromSide":"bottom","toNode":"c988c97f555a4499","toSide":"top"}
	]
}