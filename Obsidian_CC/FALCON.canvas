{
	"nodes":[
		{"id":"f8bfb8daa4d52fb8","type":"group","x":-500,"y":-100,"width":1700,"height":2280,"label":"Falcon Specification (v1.2 â€” 01/10/2020)"},
		{"id":"6de6b14243f8a14a","type":"text","text":"Motivation\n- Shrink keys (most schemes have larger keys than prequant schemes, larger sigs, or both)\n- Longer signing process compared to FIPS 204 (Dilithium) and FIPS 205 (SPHINCS+)\n\t- https://csrc.nist.gov/Projects/post-quantum-cryptography/selected-algorithms","x":-480,"y":-500,"width":720,"height":240},
		{"id":"2de09c1e433265fb","type":"text","text":"Signing process (Reference implementation) - Falcon 1024\nhttps://falcon-sign.info/impl/falcon.h.html","x":-480,"y":-220,"width":483,"height":60},
		{"id":"bceef7cc563ccf14","type":"text","text":"2.2 Gentry-Peikert-Vaikuntanathan Framework (GPV)\n- First a preimage $c_0 \\in \\mathbb{Z}^m_q$  is computed, which verifies $c_0 A^t=H(m)$\n\t- Where $A$ is the full-rank matrix found in the public key ($A \\in \\mathbb{Z}^{n\\times m}_q$)\n\t- Where $H : \\{0,1\\}^* \\rightarrow \\mathbb{Z}^n_q$ is a hash function \n\t\t- Binary input of any length \n\t\t- Returns a set of integers\n\t\t\t- Set length of N\n\t\t\t- Set ranges between 0 and q-1\n\t- As $c_0$ is not required to be short and $m \\geq n$, this is simply done with standard linear algebra (??) \n- A matrix $B$ is then used to compute a vector $v \\in \\Lambda^{\\perp}_q$ close to $c_0$ \n\t- Where $B$ is a matrix in the private key ($B \\in \\mathbb{Z}^{m\\times m}_q$), generating $\\Lambda^{\\perp}_q$\n\t- Where $\\Lambda^{\\perp}_q$ is the lattice orthogonal to $\\Lambda$ modulo q: for any $x\\in \\Lambda$ and $y \\in \\Lambda^{\\perp}_q$\n\t\t- Thus $<x,y>=0$ mod q \n\t\t- Rows of $A$ and $B$ pairwise orthogonal: $B \\times A^t = 0$\n\t- Trapdoor function\n- Differences $s = c_0 - v$ is a valid signature\n\t- $sA^t = c_0A^t - vA^t = c - 0 = H(m)$\n\t- If $c_0$ and $v$ are close enough, $s$ is short\n- Description of sig scheme is also found in GGH and NTRUSign schemes, but these are vulnerable to total break attacks\n\t- Apparently, since $v$ is calculated differently, GPV is still quantum resilient (?)\n\t- $v$ is computed using an algo called round-off algorithm in GGH and NTRUSign\n\t\t- Leaks information of B \n- In GPV, $v$ is calculated by solving the closest vector problem (cvp) through randomized rounding \n\t- https://dl.acm.org/doi/pdf/10.5555/338219.338661\n\t- Based on abstract v\n\t- Given bases of a lattice (In this case $B$) and a vector $x$ ($c_0$ in this case) not in the lattice, the heuristic will with high probability find the vector in the lattice that is closest to $x$ \n\t- Time req by heuristic depends on distance between $x$ and closest lattice vector ($s$ in this case) and quality of bases (?)\n- Algorithm introduced above is known as a trapdoor sampler","x":-437,"y":-80,"width":440,"height":580,"color":"5"},
		{"id":"85944130cce60a56","type":"text","text":"2.3 NTRU Lattices\n- If emphasis is placed on security without compromise, standard lattices without any structure would be used\n- However, since goal of FALCON is compactness, NTRU lattices with additional ring structure is used\n\t- Based on https://perso.ens-lyon.fr/damien.stehle/downloads/ntruenc.pdf\n\t- Based on abstract v\n\t\t- Presents a modified version of NTRUEncrypt to make it provably secure in standard model\n\t\t\t-  ... Under the assumption quantum hardness of standard worst-case lattice problems, restricted to a family of lattices related to some cyclotomic fields\n\t\t- Key contribution is to show that standard key polynomials are selected by rejection from Gaussians, then the public key, which is their ratio, is statistically indistinguishable from uniform over its domain (?)","x":40,"y":-80,"width":440,"height":200},
		{"id":"294c71bf4eefaed9","type":"text","text":"2.3.1 Introduction to NTRU Lattices\n- Let $\\Phi = x^n + 1$ for $n = 2^k$ and $q \\in \\mathbb{H}^*$ \n- A set of NTRU secrets consists of 4 polynomials \n  $f,g,F,G \\in \\mathbb{Z}[x]/(\\Phi)$ \n  which verify the equation \n  $fG-gF = q$ mod $\\Phi$\n\t- $h$ is usually the public key\n\t- $f,g,F,G$ are usually secret keys\n- Provided $f$ is invertible modulo $q$, we can define the polynomial $h \\leftarrow g \\cdot f^{-1}$ mod $q$\n\t- You could check matrices $[1 \\: h; \\: 0 \\: q]$ and $[f \\: g; \\: F \\: G]$, but even when $f,g$ are small, it remains  hard to find small polynomials $f',g'$ such that $h=g'\\cdot (f')^{-1}$ \n- $h$ defines an algebraic relation between secret polynomials $(f,g)$\n\t- Anyone can verify, but only those with trapdoor bases ($B$, private key) can sign","x":40,"y":120,"width":440,"height":380},
		{"id":"c318f6a6bbf6706b","type":"text","text":"2.3.2 Instantiation with GPV framework\n- The public basis is $A = [1 | h*]$, equivalent to knowing h\n- Secret bases $B = [g \\: -f; \\: G \\: -F]$ \n- Check that $A, B$ are orthogonal ($B \\times A^* = 0$ mod $q$)\n\t- Signature of a message m consists of a salt (nonce) $r$ and a pair of polynomials $(s_1. s_2)$\n\t- Such that $s_1 + s_2h = H(r||m)$\n\t\t- Hash and sign lattice scheme\n\t\t- Means verifier can recompute hash challenge and check polynomials is a valid preimage under public key\n\t- Intuition:\n\t\t- Verifier, given signature $(r, s_1, s_2)$, computes $e=H(r||m)$\n\t\t- If $s_1 + s_2h=e$ and $s_1,s_2$ are short enough, signature is valid\n- ","x":40,"y":500,"width":440,"height":220},
		{"id":"7ad22aa2e1427c0a","type":"text","text":"2.3.3 Choosing optimal parameters\n- Trapdoor sampler samples signatures of norm proportional to $||B||_{GS}$ \n\t- Where $||B||_{GS}$ denotes the Gram-Schmidt norm of B\n- Generate $f,g$ as discrete Gaussians in $\\mathbb{Z}[x]/(\\Phi)$ centered at 9, so that the expected value of $||(f,g)||$ is about $1.17\\sqrt{q}$\n\t- Once this is done, very efficient ways to compute $||B||_{GS}$ are known\n\t- If $||B||_{GS}$ is larger than $1.17\\sqrt{q}$, $f,g$'s are regenerated and procedure starts over","x":40,"y":720,"width":440,"height":360,"color":"5"},
		{"id":"77188bd91c926329","type":"text","text":"2.4 Fast Fourier Sampling\n- A trapdoor sampler takes an input a Matrix $A$, a trapdoor $T$, a target $c$ and outputs a short vector $s$ such that $s^t A = c$ mod $q$\n- As noted, this is equivalent to finding $v \\in \\Lambda^\\perp_q$ close to $c_0$ \n- Types of existing trapdoor samplers \n\t- Kein's algorithm (refer to section 2.3.3 and calculation of $v$ in section 2.2)**\n\t\t- Takes as a trapdoor the matrix $B$\n\t\t- Outputs vectors $s$ of norm proportional to $||B||_{GS}$ \n\t\t- Short and good for security, but its time and space complexity are $O(m^2)$\n\t- Peikert's proposition of randomized version of the round-off algorithm\n\t\t- A nice thing is $B$ has structure over rings so it can be made to run at time and spice $O(m \\: log(m))$\n\t\t- However, it outputs vectors of norm proportional the the spectral norm $||B||_2$ of $B$ which is larger than Klein's (worse for security)\n\t- Micciancio and Peikert \n\t\t- $A$ (matrix found in public key) and its trapdoor are structured in a way which allows for simple and efficient trapdoor sampling\n\t\t- Not straightforwardly compatible with NTRU lattices and yet to reach same level of compactness \n\t- **Ducas and Prest - fast Fourier nearest plane**\n\t\t- **Varient of Babai's nearest plane algo for lattices over rings**\n\t\t- **Recursive method similar to FFT**\n\t\t- **Can be randomized - results in trapdoor sampler which combines quality of Klein's and efficiency of Peikerts** \n\t\t- **Can be used over NTRU lattices**\n\t- **^^ Used in Falcon**\n- $\\sigma = \\eta_\\in (\\mathbb{Z}^{2n})\\cdot ||B||_{GS}$\n\t- Not entirely sure what this means yet...","x":520,"y":-80,"width":440,"height":460,"color":"5"},
		{"id":"bf356a8dafa271ca","x":40,"y":1120,"width":440,"height":440,"type":"text","text":"3.5 FFT and NTT\n- ** Continue to 3.6 in this section as well.\n- ** Continue to 3.7 in this section as well."},
		{"id":"00e8ab52807e4c94","x":-437,"y":1120,"width":440,"height":440,"color":"5","type":"text","text":"2.7 Advantages and Limitations of Falcon\n- Main idea was to provide small pk and sig sizes\n- Signature generation and verification procedures are very fast - especially for verification\n\t- \"Even signature algo can perform more than 1000 signatures per second on a moderately powered computer\"\n- **Falcon is modular - GPV framework described with NTRU lattices in earlier sections, but another class of lattices could be used**\n- **FFT for trapdoor sampler was suggested, but different trapdoor samplers could be used instead**\n- **Signing procedure uses FP arithmetic with 53 bits of precision is a major limitation on constrained devices**\n\t- **One challenging next step is implementing FLACON in a masked fashion**\n- "},
		{"id":"a459a1586d2d5214","type":"text","text":"3.8 ","x":520,"y":1120,"width":440,"height":440}
	],
	"edges":[
		{"id":"b25566fca4efcef5","fromNode":"6de6b14243f8a14a","fromSide":"bottom","toNode":"2de09c1e433265fb","toSide":"top"}
	]
}